<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
</head>

<dom-module id="wallcology-d3">
  <style>

    svg {
    }

    path {
      stroke: steelblue;
      stroke-width: 2;
      fill: none;
    }

    rect .plot {
      fill: #ddd;
      /*opacity: 0.5;*/
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: grey;
      stroke-width: 1;
    }

    .legend {
      font-size: 16px;
      font-weight: bold;
      text-anchor: middle;
    }

    .unselected {
      border: 0px solid #021a40;
    }

    .selected {
      border: 10px solid #021a40;
    }

    .pink {
      background-color: var(--paper-pink-500);
    }

    .hcontainer {
      @apply(--layout-horizontal);
      @apply(--layout-center-justified);
    }

    paper-material {
      background-color: white;;
      height: 100%;
      margin-top: 2px;
      padding: 6px;
    }

  </style>
  <template>
    <iron-ajax id="d3Ajax"
               contentType="application/json"
               url="http://beta.json-generator.com/api/json/get/4yOtVcHh"
               params=""
               handle-as="json"
               on-response="handlePopulationDataResponse" loading="{{loading}}" method="GET" auto verbose>

    </iron-ajax>
    <paper-material elevation="1">
      <div class="hcontainer">
        <div id="WallGraphs"></div>
      </div>
    </paper-material>
  </template>
  <script>
    // element registration
    Polymer({
      is: 'wallcology-d3',

      // add properties and methods on the element's prototype
      properties: {
        // declare properties for the element's public API
        chartData: {
          type: Array,
          value: [],
          notify: true
        },
        currentHabitat: {
          type: Object,
          notify: true,
          observer: 'currentHabitatChanged'
        },
        selectedBugs: {
          type: Array,
          notify: true,
          value: [],
        },
        charts: {
          type: {},
          notify: true,
          value: {},
        },
      },
      observers: [
        'selectedBugsChanged(selectedBugs.*)'
      ],
      selectedBugsChanged: function (changeRecord) {
        console.log('D3 selectedBugs changed : ' + changeRecord.value);

        if( this.currentHabitat !== undefined && this.selectedBugs !== undefined ) {


          for(var i = 0; i < this.selectedBugs.length; i++ ){
            var bug = this.selectedBugs[i];
            if( !this.charts.hasOwnProperty(bug) ) {
              this.charts[bug] = this.barChart(i, bug);
              this.charts[bug].plot(this.getData(this.chartData[i].values, bug));
            }
          }
        }
      },
      currentHabitatChanged: function (newValue, oldValue) {
        //console.log('D3 currentHabitatChanged oldValue: ' + oldValue + ' : ' + newValue);
      },

      handlePopulationDataResponse: function (e) {
        this.chartData = d3.nest()
          .key(function(d) { return d.id })
          .key(function(d) { return d.symbol })
          .entries(e.target.lastResponse);

        console.log(this.chartData);

        var parseDate = d3.time.format("%c").parse;

        this.chartData.forEach(function(habitat) {
          console.log('FUCK YOU: ' + habitat);
          habitat.values.forEach(function(fuckYouData, i) {
            fuckYouData.values.forEach(function(d) { d.date = parseDate(d.date); d.population = +d.population; });
            fuckYouData.maxPop = d3.max(fuckYouData.values, function(d) { return d.population; });
            fuckYouData.sumPop = d3.sum(fuckYouData.values, function(d) { return d.population; });
          })
        });

      },
      getData: function(Blob, target) {
        var data = Blob.filter(function(d) {
          if (d.key === target) {
            return d;
          }
        });
        return data[0];
      },

      barChart: function (_top, key) {
        // console.log(data)

        var critters = [ "green", "brown", "orange", "grey", "cherry"];
        var colorKey = d3.scale.ordinal()
          .domain(critters)
          .range(["#d62728", "#2ca02c", "#fdff00", "#9f5d30", "#2e6721"]);

        var margin = {top: 40, right: 40, bottom: 40, left:40},
          width = window.innerWidth,
          height = (window.innerHeight * 0.5)*.6;
        // height = (window.innerHeight * 0.5) * 0.33;

        var x = d3.time.scale()
          // .domain(d3.extent(data.values, function(d) { return d.date; }))
          .rangeRound([0, width - margin.left - margin.right]);

        var y = d3.scale.linear()
          // .domain([0, data.maxPop])
          .range([height - margin.top - margin.bottom, 0]);

        var xAxis = d3.svg.axis()
          .scale(x)
          .ticks(10, 1)
          .tickSize(-height + margin.top + margin.bottom)
          .tickPadding(8);

        var yAxis = d3.svg.axis()
          .scale(y)
          .orient('left')
          .ticks(2)
          .tickPadding(10)
          .tickSize(-width);;

        // set up the svg
        var svg = d3.select('#WallGraphs').append('svg')
          .attr('class', 'chart ' + key) //  + data.key
          .attr('width', width)
          .attr('height', height)
          .style('position','relative')
          .style('display','block')
          .style('left', 0)
          .style('top', _top)
          .append('g')
          .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')')
        // .call(zoom);

        svg.append('rect')
          .attr('width', width)
          .attr('height', height - margin.top - margin.bottom)
          .attr('class', 'plot')


        var clip = svg.append('clipPath')
          .attr('id', 'clip')
          .append('rect')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', width)
          .attr('height', height - margin.top - margin.bottom);

        function myChart() {
          svg.append('g')
            .attr('class', 'x axis')
            .attr('transform', 'translate(0, ' + (height - margin.top - margin.bottom) + ')')
            .call(xAxis)
            .selectAll('text')
            .attr('y', 0)
            .attr('x', 9)
            .attr('dy', '.35em')
            .attr('transform', 'rotate(90)')
            .style('text-anchor', 'start');

          svg.append('g')
            .attr('class', 'y axis')
            .call(yAxis);
        }

        myChart.plot = function(plotData) {
          console.log('plot', key, plotData)
          x.domain(d3.extent(plotData.values, function(d) { return d.date; }))
          y.domain([0, plotData.maxPop])

          function zoomed() {
            svg.select('.x.axis')
              .call(xAxis)
              .selectAll('text')
              .attr('y', 0)
              .attr('x', 9)
              .attr('dy', '.35em')
              .attr('transform', 'rotate(90)')
              .style('text-anchor', 'start');

            svg.selectAll('g.bar rect').attr('transform', 'translate(' + d3.event.translate[0] + ',0)scale(' + d3.event.scale + ', 1)');
          }

          // define the behavior
          var zoom = d3.behavior.zoom()
            .x(x)
            .y(y)
            .scaleExtent([1,100])
            .on('zoom', zoomed);

          d3.selectAll('svg.chart.'+key+' g').call(zoom);

          svg.select('g.x.axis')
            .call(xAxis);

          svg.select('g.y.axis')
            .call(yAxis)

          // Data join! Attach our nested data structure
          var chart = svg.selectAll('.chart')
            .data(plotData.values)
            .enter()
            .append('g')
            .attr('class', 'bar')
            .attr('clip-path', 'url(#clip)')

          chart.each(function(d) {
            var e = d3.select(this);
            e.append('rect')
              .transition()
              .duration(700)
              .attr('x', function(d) { return x(d.date); })
              .attr('y', function(d) { return height - margin.top - margin.bottom - (height - margin.top - margin.bottom - y(d.population)) })
              .attr('width', 0.75)
              .attr('height', function(d) { return height - margin.top - margin.bottom - y(d.population) })
              .style('fill', colorKey(plotData.key))
          })

        };

        myChart();
        return myChart;
      },
      createElements: function() {

      },
      ready: function () {

        this.currentHabitat = {};
        this.selectedBugs = [];
        this.chartData = [{}];
        this.charts = {};
        this.createElements();
      }
    });
  </script>
</dom-module>
