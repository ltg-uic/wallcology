<!--<link rel="import" href="./shared-styles/shared-styles.html">-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.6/moment.min.js"></script>
<dom-module id="population-app">
  <template>
    <style include="shared-styles"></style>
    <style>
      :host {

        //datepicker
        --primary-background-color: white;
      }

      google-chart {
        height: 150px;
        width: 100%;
        background-color: #ffffff;
        padding: 0px;
        margin: 0px;
      }

      iron-icon {
        width: 60px;
        height: 60px;
        margin-left: 5px;
      }

      .dateSpacer {
        height: 80px;
        width: 80px;
        padding: 0px;
        margin: 0px;
      }

      .leftspacer {
        margin-left: 70px;
      }

      .rightspacer {
        margin-right: 30px;
      }

      .rightpadder {
        margin-right: 0px;
      }

      .nopadding {
        padding: 0px;
        margin: 0px;
      }

      .startdateSpacer {
        padding: 0px;
        margin: 200px;
        width: 0px;
      }

      paper-toolbar ::shadow #topBar {
        padding: 0 4px;
        background-color: white;
      }

      .graph-icon {
        padding: 0 4px;
      }

      .button-title {
        color: #000;
        text-align: center;
        font-size: 11px;
        margin-top: 2px;
      }

      paper-button.colorful {
        color: white;
        background: #237599;
        margin-top: 3px;
        font-size: 12px;
      }



    </style>

    <section>
    <nutella-connector connected={{connected}} id="nutellaConn" hostname="ltg.evl.uic.edu" appid="wallcology"
                       runid="default"
                       componentid="wallcology_admin" roomcast></nutella-connector>
    <paper-toolbar>

      <div class="start">
        <div class="vertical-section-container">
          <div class="vertical-section">
            <paper-button id="startDateButton" on-tap="showStartDateDialogAction" class="colorful"><span>{{formatButtonSDate(startDate)}}</span>
            </paper-button>
          </div>
          <div class="vertical-section center">
            <div class="button-title">START</div>
          </div>
        </div>
      </div>
      </div>
      <div class="center flex">
        <div class="horizontal-section-container">

          <div class="horizontal-section">
            <wallcology-selector id="ws" toggle-selectors="{{toggleSelectors}}" button-selectors="{{buttonSelectors}}"
                                 max-selections="4" selected-items="{{selectedItems}}"
                                 current-toggle="{{currentToggle}}"></wallcology-selector>
          </div>
        </div>
      </div>
      <div class="end">
        <div class="vertical-section-container">
          <div class="vertical-section">
            <paper-button id="endDateButton" class="colorful" on-tap="showEndDateDialogAction"><span>{{formatButtonEDate(endDate)}}</span>
            </paper-button>
          </div>
          <div class="vertical-section center">
            <div class="button-title">END</div>
          </div>
        </div>
      </div>
    </paper-toolbar>

    <div class="vertical-section-container">
      <template is="dom-repeat" items="{{graphs}}">
        <section>
          <div class="vertical-section center">

            <div class="horizontal layout center graph-icon">
              <iron-icon src="{{item.highlightUrl}}" style="width: 60px;"></iron-icon>

              <div class="center flex rightpadder">
                <google-chart auto-fit-on-attach id="{{chartName(item.index)}}"
                              type='column'
                              options='{{item.options}}'
                              data={{item.data}}>
                </google-chart>

              </div>
            </div>

          </div>
        </section>
      </template>
    </div>

    <!-- YYYY-MM-DD -->
    <paper-dialog id="startDateDialog" class="paper-date-picker-dialog" modal
                  on-iron-overlay-closed="dismissDialog">
      <paper-date-picker id="startDatePicker" date="{{tempStartDate}}" min-date="{{endDate}}"></paper-date-picker>
      <div class="buttons">
        <paper-button dialog-dismiss>Cancel</paper-button>
        <paper-button dialog-confirm autofocus>OK</paper-button>
      </div>
    </paper-dialog>

    <paper-dialog id="endDateDialog" class="paper-date-picker-dialog" modal
                  on-iron-overlay-closed="dismissDialog">
      <paper-date-picker id="endDatePicker" date="{{tempEndDate}}" min-date="2015-10-12"></paper-date-picker>
      <div class="buttons">
        <paper-button dialog-dismiss>Cancel</paper-button>
        <paper-button dialog-confirm autofocus>OK</paper-button>
      </div>
    </paper-dialog>

    <!--<paper-dialog id="modal" modal>-->
      <!--<p>{{alertMessage}}</p>-->

      <!--<div class="buttons">-->
        <!--<paper-button dialog-confirm autofocus>OK</paper-button>-->
      <!--</div>-->
    <!--</paper-dialog>-->

</section>
  </template>

  <script>
    // element registration
    Polymer({
      is: 'population-app',

      // add properties and methods on the element's prototype
      properties: {
        // declare properties for the element's public API
        selectedItems: {
          type: Array,
          notify: true,
          value: []
        },
        currentToggle: {
          type: Object,
          notify: true,
          value: function () {
            return {};
          },
          observer: 'currentToggleChanged'
        },
        toggleSelectors: {
          type: Array,
          notify: true,
          value: [
            {
              'items': [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
              ],
              'name': 'Habitat 1',
              'index': 0,
            },
            {
              'items': [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
              ],
              'name': 'Habitat 2',
              'index': 1,
            },
            {
              'items': [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
              ],
              'name': 'Habitat 3',
              'index': 2,
            },
            {
              'items': [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
              ],
              'name': 'Habitat 4',
              'index': 3,
            }
          ]
        },
        buttonSelectors: {
          type: Array,
          notify: true,
          value: [
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_00.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_00_0.svg',
              'index': 0,
              'color': '#FFC91B',
              'type': 'h'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_01.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_01_0.svg',
              'index': 1,
              'color': '#5A6372',
              'type': 'p'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_02.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_02_0.svg',
              'index': 2,
              'color': '#FFDD00',
              'type': 'h'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_03.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_03_0.svg',
              'index': 3,
              'color': '#2C4721',
              'type': 'p'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_04.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_04_0.svg',
              'index': 4,
              'color': '#502B6E',
              'type': 'r'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_05.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_05_0.svg',
              'index': 5,
              'color': '#99cc33',
              'type': 'r'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_06.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_06_0.svg',
              'index': 6,
              'color': '#8975B5',
              'type': 'h'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_07.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_07_0.svg',
              'index': 7,
              'color': '#FAAA19',
              'type': 'h'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_08.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_08_0.svg',
              'index': 8,
              'color': '#899C7C',
              'type': 'p'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_09.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_09_0.svg',
              'index': 9,
              'color': '#4AB6C8',
              'type': 'r'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/species_10.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/species_10_0.svg',
              'index': 10,
              'color': '#68734F',
              'type': 'r'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/env_temp.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/env_temp_0.svg',
              'index': 11,
              'color': '#FF5722',
              'type': 'et'
            },
            {
              'highlightUrl': 'https://ltg.cs.uic.edu/WC/icons/env_pipe.svg',
              'activeUrl': 'https://ltg.cs.uic.edu/WC/icons/env_pipe_0.svg',
              'index': 12,
              'color': '#795548',
              'type': 'ep'
            }
          ]
        },
        graphs: {
          type: Array,
          notify: true,
          value: []
        },
        envEventHistories: {
          type: Array,
          notify: true,
          value: []
        },
        chartOptions: {
          type: Object,
          notify: true,
          value: {
            legend: {position: 'none'},
            tooltip: {
              trigger: 'none'
            },
            viewWindow: {},
            enableInteractivity: false,
            animation: {
              startup: true,
              duration: 250,
              easing: 'inAndOut',
              //easing: 'out'
            },
            chartArea: {left: '5%', width: '93%', height: '75%'},
            vAxis: {
              minValue: 0,
              maxValue: 0.1,
              textStyle: {
                fontSize: 14
              }
            },
            hAxis: {
              textPosition: 'out',
              textStyle: {
                fontSize: 14
              },
              gridlines: {
                count: -1,
                units: {
                  days: {format: ['M/d']},
                  hours: {format: ['h a']},
                }
              },
              minorGridlines: {
                units: {
                  hours: {format: ['h a']},
                  minutes: {format: ['h:mm a']}
                }
              }
            }
          }
        },
        maxes: {
          type: Array,
          value: []
        },
        tempStartDate: {
          type: Date,
        },
        tempEndDate: {
          type: Date,
        },
        startDate: {
          type: Date,
          observer: 'startDateChanged'
        },
        endDate: {
          type: Date,
          observer: 'endDateChanged'
        },
        pickerDateFormat: {
          type: String,
          notify: false,
          value: 'MM-DD-YYYY'
        },
        alertMessage: {
          type: String,
          notify: true,
          value: ''
        },
        connected: {
          type: Boolean,
          notify: true,
          value: false,
          observer: 'connectedChanged'
        },
        defaultR: {
          type: Number,
          value: 0.0
        },
        defaultH: {
          type: Number,
          value: 0.0
        },
        defaultP: {
          type: Number,
          value: 0.0
        },
        defaultE: {
          type: Number,
          value: 0.0
        },
        debug: {
          type: Boolean,
          value: false
        }
      },

      //{r: 0.025, h: 1.0, p: 1.0, e: 1.0}
      observers: [
        'selectedItemsChanged(selectedItems.*)',
        'toggleSelectorsChanged(toggleSelectors.*)',
        'buttonSelectorsChanged(buttonSelectors.*)',
        'graphsChanged(graphs.*)'
      ],
      graphsChanged: function (changeRecord) {
        if (this.debug) {
          console.log('graphsChanged', changeRecord);
        }

        var maxSelect = this.$.ws.maxSelections;


        //console.log('THIS SELECTED ITEMS: ' + this.graphs + ' max ' + maxSelect);

//        if( this.graphs.length > maxSelect ) {
//          alert('HEY! Why are you clicking so fast! The bug counters need enough time to give you a result!\n Refresh the Page');
//          return;
//        }

      },
      selectedItemsChanged: function (changeRecord) {

        var maxSelect = this.$.ws.maxSelections;


        //console.log('THIS SELECTED ITEMS: ' + this.selectedItems + ' max ' + maxSelect);

        if( this.selectedItems.length > maxSelect ) {
          alert('HEY! Why are you clicking so fast! The bug counters need enough time to give you a result!\n Refresh the Page');
          return;
        }

        if (this.debug) {
          console.log('selectedItemsChanged', changeRecord);
        }
        if (changeRecord.path === 'selectedItems.splices') {

          var is = changeRecord.base.splices.indexSplices[0];

          if (is.addedCount > 0) {
            var l = changeRecord.base.length;
            var species = changeRecord.base[l - 1];
            if (species.index > 10) {
              this.updateGraph(species, 'environment_history');
            } else {
              this.updateGraph(species, 'population_history');
            }
            //this.updateEventHistoryPoints();
          } else if (is.removed[0] !== undefined) {
            var s = is.removed[0];
            for (var i = 0; i < this.graphs.length; i++) {
              var g = this.graphs[i];
              if (g.index === s.index) {
                this.splice('graphs', i, 1);
                this.recomputeScale(g);
              }
            }

            for (var j = 0; j < this.graphs.length; j++) {
              var previousGraph = this.graphs[j];
              if (j === this.graphs.length - 1) {
                this.updateGraphAxis(previousGraph, 'out');
              } else {
                this.updateGraphAxis(previousGraph, 'none');
              }
              this.redrawChart(previousGraph);

            }


          }
          // a user was added or removed
        } else {
          // an individual user or its sub-properties changed
          // check "changeRecord.path" to determine what changed
        }
      },
      resetScale: function (type) {
        var index = this.currentToggle.index;
        if (type === 'r') {
          this.maxes[index].r = this.defaultR;
          return;
        } else if (type === 'h') {
          this.maxes[index].h = this.defaultH;
          return;
        } else if (type === 'p') {
          this.maxes[index].p = this.defaultP;
          return;
        } else if (type === 'ep') {
          this.maxes[index].ep = this.defaultE;
        } else if (type === 'et') {
          this.maxes[index].et = this.defaultE;
        }
      },
      toggleSelectorsChanged: function (changeRecord) {
        if (this.debug) {
          console.log('toggleSelectorsChanged', changeRecord);
        }
      },
      buttonSelectorsChanged: function (changeRecord) {
        if (this.debug) {
          console.log('buttonSelectorsChanged', changeRecord);
        }
      },
      currentToggleChanged: function (newValue, oldValue) {
        if (this.debug) {
          console.log('newValue oldValue', JSON.stringify(newValue), JSON.stringify(oldValue));
        }
        this.set('selectedItems', []);
        this.clearAllGraphs();
      },
      showStartDateDialogAction: function () {
        this.$.startDateDialog.toggle();
      },
      showEndDateDialogAction: function () {
        this.$.endDateDialog.toggle();
      },
      dismissDialog: function (e) {
        if (e.detail.confirmed) {
          if (e.target.id === 'startDateDialog') {
            var ts = moment(this.tempStartDate).format().valueOf();
            var ee = moment(this.endDate).format().valueOf();
            if ( ee > ts) {
              this.startDate = this.$.startDatePicker.date;
              this.updateAllGraphs();
            } else {
              this.showStartDateDialogAction();
            }
          } else if (e.target.id === 'endDateDialog') {
            var te = moment(this.tempEndDate).format().valueOf();
            var ss = moment(this.startDate).format().valueOf();
            if ( te > ss ) {
              this.endDate = this.$.endDatePicker.date;
              this.updateAllGraphs();
            } else {
              this.showEndDateDialogAction();
            }
          }
        } else if(e.detail.canceled) {
          if (e.target.id === 'startDateDialog') {
            this.tempStartDate = this.startDate;
          }
        }
      },
      checkDatesValid: function () {

        if (moment(this.startDate).isSame(this.endDate)) {
          return true;
        } else if (moment(this.startDate).isAfter(this.endDate)) {
          return false;
        } else if (moment(this.endDate).isBefore(this.startDate)) {
          return false;
        } else if (moment(this.endDate).isAfter(new Date())) {
          return false;
        } else {
          return true;
        }
      },
      startDateChanged: function (newValue, oldValue) {
        if (this.debug) {
          console.log('startDateChanged', newValue, oldValue);
        }
      },
      endDateChanged: function (newValue, oldValue) {
        if (this.debug) {
          console.log('endDateChanged', newValue, oldValue);
        }
      },
      clearAllGraphs: function () {
        this.set('graphs', []);
        this.set('envEventHistories', []);
      },
      updateEventHistoryPoints: function () {
        var sdate = moment(this.startDate).startOf('day').valueOf();
        var edate = moment(this.endDate).endOf('day').valueOf();
        var habitatIndex = this.currentToggle.index;
        var message = {habitat: habitatIndex, from: sdate, to: edate};

        this.addEventHistoryPoints(habitatIndex, sdate, edate, message);
      },
      updateGraph: function (species, type) {
        var sdate = moment(this.startDate).startOf('day').valueOf();
        var edate = moment(this.endDate).endOf('day').valueOf();
        var habitatIndex = this.currentToggle.index;

        var message;

        //environmental_variable: 0, 0=temperature 1=pipe length 2=brick area

        if (type === 'environment_history') {
          if (species.index === 11) {
            species.index = 0;
          } else if (species.index === 12) {
            species.index = 1;
          }

          message = {
            habitat: habitatIndex,
            environmental_variable: species.index,
            points: 100,
            from: sdate,
            to: edate
          };
        } else if (type === 'population_history') {
          message = {habitat: habitatIndex, species: species.index, points: 100, from: sdate, to: edate};
        }


        this.addHistoryGraph(species, habitatIndex, sdate, edate, message, type);
      },
      updateAllGraphs: function () {
        for (var i = 0; i < this.selectedItems.length; i++) {
          var species = this.selectedItems[i];
          if (species.index >= 11) {
            this.updateGraph(species, 'environment_history');
          } else {
            this.updateGraph(species, 'population_history');
          }

        }
      },
      addHistoryGraph: function (species, habitatIndex, sdate, edate, message, type) {
//        var selectorButtons = this.$.ws.getAllButtons();
//        selectorButtons[species.index].disabled = true;
        var me = this;
        var messageType = type;
        var sDateLocal = sdate;
        var eDateLocal = edate;
        var sSpecies = species;
        console.log(JSON.stringify(message));
        this.$.nutellaConn.nutella.net.request(type, message, function (response) {
          var r = response;
          console.log('Response: ' + sSpecies.r + sSpecies.index + ': ');
          console.log('R: ',r);
          var t = [
            [{label: 'Days', type: 'date'}, {label: 'Counts', type: 'number'}, {type: 'string', role: 'style'}]
          ];
          var min = new Date(moment(sdate).valueOf());
          var max = new Date(moment(edate).valueOf());

          if (r.length > 0) {
            //environmental_variable: 0, 0=temperature 1=pipe length 2=brick area
            if (messageType === 'environment_history') {
              if (sSpecies.index === 0) {
                sSpecies.index = 11;
              } else if (sSpecies.index === 1) {
                sSpecies.index = 12;
              }


              async.each(r, function(d, callback) {
//                for (var i1 = 0; i1 < r.length; i1++) {
//                  var d1 = 'Date(' + moment(r[i1].timestamp).valueOf() + ')';
//                  t.push([d1, r[i1].value, sSpecies.color]);
//                }

                var d1 = 'Date(' + moment(d.timestamp).valueOf() + ')';
                t.push([d1, d.value, sSpecies.color]);



                 callback();
              }, function(err){


                var envMax = me.findMaxValue(t);
                me.setGraphMax(sSpecies, envMax);

                var foundENVGraphs = me.graphs.filter(function (el) {
                  return (el.index === sSpecies.index);
                });

                if (foundENVGraphs.length > 0) {
                  var foundEnvGraph = foundENVGraphs[0];
                  foundEnvGraph.data = t;
                  var envTextPosition = foundEnvGraph.options.hAxis.textPosition;
                  //el.options = me.chartOptions;
                  var envGraphMax = me.getGraphMax(foundEnvGraph);
                  foundEnvGraph.options.vAxis.maxValue = envGraphMax;
                  me.updateGraphAxis(foundEnvGraph, envTextPosition, min, max);
                  me.redrawChart(foundEnvGraph);
                } else {
                  //we have a new one
                  //envMax = me.findMaxValue(t);
                  me.setGraphMax(sSpecies, envMax);
                  me.drawGraph(sSpecies, t, 'environment_history', sdate, edate);
                }
              });




            } else if (messageType === 'population_history') {


              async.each(r, function(d, callback) {
                var d2 = 'Date(' + moment(d.timestamp).valueOf() + ')';
                t.push([d2, d.population, sSpecies.color]);




                callback();
              }, function(err){

                var hisMax = me.findMaxValue(t);
                me.setGraphMax(sSpecies, hisMax);


                var foundHISGraphs = me.graphs.filter(function (el) {
                  return (el.index === sSpecies.index);
                });


                if (foundHISGraphs.length > 0) {

                  var foundHisGraph = foundHISGraphs[0];

                  me.recomputeScale(foundHisGraph);


                  foundHisGraph.data = t;
                  var hisTextPosition = foundHisGraph.options.hAxis.textPosition;
                  //el.options = me.chartOptions;
                  me.updateGraphAxis(foundHisGraph, hisTextPosition, min, max);
                  me.redrawChart(foundHisGraph);


                } else {
                  //we have a new one
                  hisMax = me.findMaxValue(t);
                  me.setGraphMax(sSpecies, hisMax);
                  me.drawGraph(sSpecies, t, 'population_history', sdate, edate);

                }

              });

            }


          } else {
            //zero results
            var popFirstDate = 'Date(' + moment(sDateLocal).add(30, 's').valueOf() + ')';
            //add one minute to the start time and set it 0
            t.push([popFirstDate, 0, sSpecies.color]);

            var popLastDate = 'Date(' + moment(eDateLocal).subtract(30, 's').valueOf() + ')';
            //add one minute to the start time and set it 0
            t.push([popLastDate, 0, sSpecies.color]);

            me.drawGraph(sSpecies, t, messageType, sdate, edate);

            setTimedOut(function(){
              selectorButtons[sSpecies.index].disabled = false;
            }, 1000);
          }




        });


      },
      recomputeScale: function (graph) {
        if (graph !== undefined) {
          var type = graph.type;

          //reset
          this.resetScale(type);

          for (var i = 0; i < this.graphs.length; i++) {
            var a = this.graphs[i];
            if (type === a.type) {
              this.setGraphMax(a, this.findMaxValue(a.data));
            }
          }

          //set the new max
          for (var k = 0; k < this.graphs.length; k++) {
            var b = this.graphs[k];
            if (type === b.type && b.index !== graph.index) {

              var textPosition = b.options.hAxis.textPosition;
              //el.options = me.chartOptions;
              var v = this.getGraphMax(b);
              b.options.vAxis.maxValue = v;
              this.updateGraphAxis(b, textPosition);
              this.redrawChart(b);
            }
          }

          //look for all for that type
        }
      },
      findMaxValue: function (numbers) {
        //because the first el is the graph heading
        var low = numbers[1][1]; // first number in array
        var high = numbers[1][1]; // first number in array

        for (var i = 1; i < numbers.length; i++) {
          if (numbers[i][1] > high) {
            high = numbers[i][1];
          }
          if (numbers[i][1] < low) {
            low = numbers[i][1];
          }
        }

        return high;
      },
      drawGraph: function (species, data, type, to, from) {

        if (this.graphs !== undefined || this.graphs[0] !== undefined) {
          //if we have previous graphs

//          var min = new Date(moment(from).subtract(1, 'minute').valueOf());
//          var max = new Date(moment(to).add(1, 'minute').valueOf());

          var min = new Date(moment(from).valueOf());
          var max = new Date(moment(to).valueOf());


          if (this.graphs.length > 0) {
            for (var j = 0; j < this.graphs.length; j++) {
              var previousGraph = this.graphs[j];
              this.updateGraphAxis(previousGraph, 'none', min, max);
              this.redrawChart(previousGraph);
            }
          }

          //add new graph
          var g = {index: species.index, type: species.type, data: data, highlightUrl: species.highlightUrl};
          g.options = JSON.parse(JSON.stringify(this.chartOptions));
          this.updateGraphAxis(g, 'out', min, max);


          this.push('graphs', g);
          if (this.debug) {
            console.log('pushed graph');
          }

        }
      },
      setGraphMax: function (species, newMax) {
        var index = this.currentToggle.index;
        var max = this.maxes[index];
        if (species.type === 'r') {
          if (newMax > this.maxes[index].r) {
            this.maxes[index].r = newMax;
          }
        } else if (species.type === 'h') {
          if (newMax > this.maxes[index].h) {
            this.maxes[index].h = newMax;
          }
        } else if (species.type === 'p') {
          if (newMax > this.maxes[index].p) {
            this.maxes[index].p = newMax;
          }
        } else if (species.type === 'et') {
          this.maxes[index].et = newMax;
        }else if (species.type === 'ep') {
          this.maxes[index].ep = newMax;
        }
      },
      getGraphMax: function (graph) {
        var index = this.currentToggle.index;
        var max = this.maxes[index];
        if (graph.type === 'r') {
          return this.maxes[index].r;
        } else if (graph.type === 'h') {
          return this.maxes[index].h;
        } else if (graph.type === 'p') {
          return this.maxes[index].p;
        } else if (graph.type === 'et') {
          return this.maxes[index].et;
        } else if (graph.type === 'ep') {
          return this.maxes[index].ep;
        }
      },
      updateGraphAxis: function (someGraph, type, min, max) {

        someGraph.options.vAxis =  {
          minValue: 0,
            maxValue: 0.1,
            textStyle: {
            fontSize: 14
          }
        };

        someGraph.options.xAxis = {
          textPosition: 'out',
            textStyle: {
          fontSize: 14
        },
          gridlines: {
            count: -1,
              units: {
              days: {format: ['M/d']},
              hours: {format: ['h a']},
            }
          },
          minorGridlines: {
            units: {
              hours: {format: ['h a']},
              minutes: {format: ['h:mm a']}
            }
          }
        };


//        var t1 = moment(min).startOf('day').valueOf();
//        var t2 = moment(max).endOf('day').valueOf();

        var t1 = moment(min);
        var t2 = moment(max);
        var t3= t1.diff(t2,'days');

        var timeTicks = [];
        if( t3 === 0 ) {
          var s = moment(min).startOf('day');
          timeTicks.push(s.valueOf());

          for(var k = 1; k < 23; k++){
            s.add(k,'h');
            timeTicks.push(s.valueOf());
          }

          timeTicks.push(moment(max).endOf('day').valueOf());
        }

        if (min !== undefined && max !== undefined) {
          someGraph.options.hAxis.minValue = t1;
          someGraph.options.hAxis.maxValue = t2;
        }

        var dataPointMax = this.getGraphMax(someGraph);

        someGraph.options.hAxis.textPosition = type;

       // someGraph.options.hAxis.ticks = ['12 AM', '12 AM'];

        var pat = '';


//          Ymax <=1, show one decimal place (e.g. 0.1, 0.2, etc.) this means that
//          for the example you show me, there would only be one label (0.1) on the y axis
//
//          if Ymax > 1, no decimal places.

          var tickMax = 0;
          if( dataPointMax <= 1 ) {

            if( dataPointMax === 0 || dataPointMax <  0.1 ) {
              tickMax = 1.0;
              someGraph.options.vAxis.format = '0.0';
            } else if( dataPointMax > 0.1 && dataPointMax <  1){
              tickMax = this.round_up(dataPointMax, 1.0);
              someGraph.options.vAxis.format = '0.#';
            }
            else if(dataPointMax === 1){
              tickMax = 1.0;
              someGraph.options.vAxis.format = '0.0';
            }

            if( someGraph.type === 'r') {
//              tickMax = tickMax * 100;
//              dataPointMax = dataPointMax * 100;
              someGraph.options.vAxis.format = '#%';
            }
            someGraph.options.vAxis.maxValue = dataPointMax;
            someGraph.options.vAxis.ticks = [{v:0, f:'0'},tickMax];
            someGraph.options.vAxis.minorGridlines = {count: 3};
            //someGraph.options.vAxis.gridlines = {count: 0};
          } else if( dataPointMax > 1) {
            //find how many digits we have before the decimal
            var vstring = dataPointMax.toString().split('.')[0];
            for( var i = 0; i < vstring.length; i++ ) {
              pat = pat + '#';
            }
            someGraph.options.vAxis.format = pat;
            someGraph.options.vAxis.maxValue = dataPointMax;
           // someGraph.options.vAxis.minorGridlines = {count: 3};
           // someGraph.options.vAxis.majorGridlines = {count: 5};
          }

          console.log('drawing graph: ' + someGraph.type + someGraph.index + ' with max datapoint of: ' + dataPointMax + ' and max tick ' + tickMax);



        someGraph.options.hAxis.gridlines.count = -1;


          switch (type) {
            case 'out':
//              someGraph.options.hAxis.minorGridlines.units.hours = {format: ['h a']};

              someGraph.options.hAxis.gridlines.units.hours = {format: ['h a']};
              someGraph.options.hAxis.gridlines.units.days = {format: ['M/d']};
              break;
            case 'none':
              someGraph.options.hAxis.gridlines.units.hours = {format: [' ']};
              someGraph.options.hAxis.gridlines.units.days = {format: [' ']};
              someGraph.options.hAxis.minorGridlines.units.hours = {format: [' ']};
              someGraph.options.hAxis.minorGridlines.units.minutes = {format: [' ']};

              break;
            default:
              console.log('no switch type');
          }

      },
      round_up: function(val, precision) {
      power = Math.pow (10, precision);
      poweredVal = Math.ceil (val * power);
      result = poweredVal / power;

        return result;
      },
      redrawChart: function (graph) {



        var chartId = this.chartName(graph.index);
        var chart = document.getElementById(chartId);
        //chart.options = graph.options;
        chart.data = graph.data;
        chart.drawChart();

      },
      connectedChanged: function (newValue, oldValue) {
      },
      ready: function () {
        this.startDate = new Date();
        this.endDate = this.startDate;
        this.tempStartDate = this.startDate;
        this.tempEndDate = this.startDate;
        this.selectedItems = [];
        this.graphs = [];
        this.envEventHistories = [];

        var start = [{
          'items': [],
          'name': 'Habitat ?  ',
          'index': -1
        }];
        this.toggleSelectors = start.concat(this.toggleSelectors);
        this.maxes = [{r: this.defaultR, h: this.defaultH, p: this.defaultP,  et: this.defaultE,
          ep: this.defaultE}, {r: this.defaultR, h: this.defaultH, p: this.defaultP,  et: this.defaultE,
          ep: this.defaultE}, {
          r: this.defaultR,
          h: this.defaultH,
          p: this.defaultP,
          et: this.defaultE,
          ep: this.defaultE
        }, {r: this.defaultR, h: this.defaultH, p: this.defaultP,  et: this.defaultE,
          ep: this.defaultE}];
      },
      chartName: function (index) {
        return 'chart' + index;
      },
      formatButtonSDate: function (someDate) {
        var formatted = moment(someDate).format('MM/DD/YY');
        return formatted;
      },
      formatButtonEDate: function (someDate) {
        var formatted = moment(someDate).format('MM/DD/YY');
        return formatted;
      },
    });
  </script>
</dom-module>
